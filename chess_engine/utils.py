import select
import sys
import time

import config
from evaluation import negamax, score_move

if sys.platform == "win32":
    import ctypes
    import msvcrt

def get_time_ms():
    return int(time.perf_counter() * 1000)


def is_input_available():
    # Check if the platform is not Windows
    if sys.platform != "win32":
        return handle_non_win32_input()
    return handle_win32_input()


def handle_win32_input():
    """
    This code was generated by ChatGPT as a translation into
    Python of the original code in C. I've tested it and it works.
    """
    init = 0
    pipe = None
    inh = None
    dw = None

    if not init:
        init = 1
        inh = msvcrt.get_osfhandle(0)
        pipe = not ctypes.windll.kernel32.GetConsoleMode(
            inh, ctypes.byref(ctypes.c_ulong())
        )

    if pipe:
        dw = ctypes.c_ulong()
        if not ctypes.windll.kernel32.PeekNamedPipe(
            inh, None, 0, None, ctypes.byref(dw), None
        ):
            return 1
        return dw.value
    else:
        dw = ctypes.c_ulong()
        ctypes.windll.kernel32.GetNumberOfConsoleInputEvents(inh, ctypes.byref(dw))
        return dw.value if dw.value > 1 else 0


# Function to read input from STDIN
def read_input():
    # GUI/user input
    input_str = ""

    # "listen" to STDIN
    if is_input_available():
        # Tell engine to stop calculating
        config.UCI_STOPPED = True

        while True:
            try:
                # read bytes from stdin
                # Important to use sys.stdin.buffer.raw.read(256) instead
                # of sys.stdin.buffer.read(256) cos the latter is a blocking
                # operation and needs all 256 bytes to be complete before
                # executing the next line of code while the former, the "raw"
                # alternative, is non-blocking and will therefore execute
                # the next line of code as soon as a newline character is entered.
                input_bytes = sys.stdin.buffer.raw.read(256)
                # print(f"input bytes has length {len(input_bytes)}")
                # print(f"Printing input bytes decoded: {input_bytes.decode('utf-8')}")
                if not input_bytes:
                    # No bytes available, break the loop
                    break
                else:
                    # Convert bytes to string and append to input
                    input_str += input_bytes.decode("utf-8")
                    if len(input_bytes) < 256:
                        break
            except EOFError:
                # End of file reached, break the loop
                break

        endc = input_str.find("\n")

        # If found new line, set value at pointer to 0
        if endc != -1:
            input_str = input_str[:endc]

        # If input is available
        if len(input_str) > 0:
            print(input_str)
            # Match UCI "quit" command
            if input_str.startswith("quit"):
                # Tell engine to terminate execution
                config.UCI_QUIT = True
                config.UCI_STOPPED = True
            # Match UCI "stop" command
            elif input_str.startswith("stop"):
                # Tell engine to terminate execution
                config.UCI_QUIT = True
                config.UCI_STOPPED = True


def commmunicate():
    if config.UCI_TIME_IS_SET and get_time_ms() > config.UCI_STOP_TIME:
        config.UCI_STOPPED = True
    read_input()


def handle_non_win32_input():
    # Create a file descriptor set
    readfds = [sys.stdin]

    # Use select.select to perform non-blocking I/O with a timeout of 0 seconds
    readable, _, _ = select.select(readfds, [], [], 0)

    # Check if stdin is readable (input available)
    return sys.stdin in readable


def search_position(depth: int):
    """
    Searches the position to given depth.
    UCI Protocol dictates it prints a so called
    'bestmove'.
    """
    # Reinitialise
    config.LEAF_NODES = 0
    config.FOLLOW_PV = 0
    config.PLY = 0
    config.SCORE_PV = 0
    config.PV_LENGTH = [0 for _ in range(config.MAX_PLY)]
    config.PV_TABLE = [
        [0 for _ in range(config.MAX_PLY)] for _ in range(config.MAX_PLY)
    ]
    config.KILLER_MOVES = [[0 for _ in range(config.MAX_PLY)] for _ in range(2)]
    config.HISTORY_MOVES = [[0 for _ in range(64)] for _ in range(12)]

    config.UCI_STOPPED = False

    # clear_transposition_table()

    # Init aspiration window
    aspiration_window = 50
    alpha = -config.INFINITY
    beta = config.INFINITY

    # Iterative deepening
    current_depth = 1
    while current_depth <= depth:

        config.FOLLOW_PV = 1

        # Get score for current position
        score = negamax(alpha, beta, current_depth)

        if score <= alpha or score >= beta:
            # Re-search at this depth with the full aspiration window
            alpha = -config.INFINITY
            beta = config.INFINITY
            continue

        # Tighten the aspiration window a little
        alpha = score - aspiration_window
        beta = score + aspiration_window

        if -config.MATE_VALUE < score < -config.MATE_SCORE:
            print(
                f"info score mate {-(score + config.MATE_VALUE) // 2 - 1} depth {current_depth} nodes {config.LEAF_NODES} pv "
                f"{' '.join(move_to_str(config.PV_TABLE[0][count]).strip() for count in range(config.PV_LENGTH[0]))}"
            )

        elif config.MATE_SCORE < score < config.MATE_VALUE:
            print(
                f"info score mate {(config.MATE_VALUE - score) // 2 + 1} depth {current_depth} nodes {config.LEAF_NODES} pv "
                f"{' '.join(move_to_str(config.PV_TABLE[0][count]).strip() for count in range(config.PV_LENGTH[0]))}"
            )

        else:
            print(
                f"info score cp {score} depth {current_depth} nodes {config.LEAF_NODES} pv "
                f"{' '.join(move_to_str(config.PV_TABLE[0][count]).strip() for count in range(config.PV_LENGTH[0]))}"
            )
        current_depth += 1
        if config.UCI_STOPPED:
            if config.PV_LENGTH[0] == 0:
                if -config.MATE_VALUE < score < -config.MATE_SCORE:
                    print(
                        f"info score mate {-(score + config.MATE_VALUE) // 2 - 1} depth {current_depth} nodes {config.LEAF_NODES} pv "
                        f"{move_to_str(config.PV_TABLE[0][0]).strip()}"
                    )

                elif config.MATE_SCORE < score < config.MATE_VALUE:
                    print(
                        f"info score mate {(config.MATE_VALUE - score) // 2 + 1} depth {current_depth} nodes {config.LEAF_NODES} pv "
                        f"{move_to_str(config.PV_TABLE[0][0]).strip()}"
                    )

                else:
                    print(
                        f"info score cp {score} depth {current_depth} nodes {config.LEAF_NODES} pv "
                        f"{move_to_str(config.PV_TABLE[0][0]).strip()}"
                    )
            print(
                f"*************** WE'RE STOPPING THE SEARCH. DEPTH SEARCHED: {current_depth}. **************"
            )
            break

    print(f"bestmove {move_to_str(config.PV_TABLE[0][0])}")


################################################
##                                            ##
##          Board State Functions             ##
##                                            ##
################################################


def copy_board_state_2():
    """
    Returns a dict containing the essential
    elements that make up the current board state
    """
    return {
        "occupancies": [itm for itm in config.OCCUPANCIES],
        "piece_bitboards": [itm for itm in config.PIECE_BITBOARDS],
        "side_to_move": config.SIDE_TO_MOVE,
        "castling_right": config.CASTLING_RIGHT,
        "en_passant_square": config.ENPASSANT_SQUARE,
        "hash_key": config.HASH_KEY,
    }


def restore_board_state_2(board_state: dict):
    config.PIECE_BITBOARDS = [itm for itm in board_state["piece_bitboards"]]
    config.OCCUPANCIES = [itm for itm in board_state["occupancies"]]
    config.SIDE_TO_MOVE = board_state["side_to_move"]
    config.CASTLING_RIGHT = board_state["castling_right"]
    config.ENPASSANT_SQUARE = board_state["en_passant_square"]
    config.HASH_KEY = board_state["hash_key"]


def copy_board_state():
    config.PIECE_BITBOARDS_COPY = [itm for itm in config.PIECE_BITBOARDS]
    config.OCCUPANCIES_COPY = [itm for itm in config.OCCUPANCIES]
    config.SIDE_TO_MOVE_COPY = config.SIDE_TO_MOVE
    config.CASTLING_RIGHT_COPY = config.CASTLING_RIGHT
    config.ENPASSANT_SQUARE_COPY = config.ENPASSANT_SQUARE


def restore_board_state():
    config.PIECE_BITBOARDS = [itm for itm in config.PIECE_BITBOARDS_COPY]
    config.OCCUPANCIES = [itm for itm in config.OCCUPANCIES_COPY]
    config.SIDE_TO_MOVE = config.SIDE_TO_MOVE_COPY
    config.CASTLING_RIGHT = config.CASTLING_RIGHT_COPY
    config.ENPASSANT_SQUARE = config.ENPASSANT_SQUARE_COPY


################################################
##                                            ##
##             Bit Operations                 ##
##                                            ##
################################################


def count_bits(bboard: int):
    """
    Given a bitboard, it returns the
    number of set bits in the bitboard."""

    # count = 0
    # while bboard > 0:
    #     bboard &= bboard - 1
    #     count += 1
    # return count

    # Much faster and more efficient to use the builtin
    # bit_count function for integer types
    return bboard.bit_count()


def get_lsb_index(bboard: int):
    """
    Given a bitboard, it returns the
    index of its least significant bit."""
    # if not bboard:
    #     return -1

    # This approach is 1.5x faster than the
    # count_bits((bboard & -bboard) -1) approach
    # proposed in the tutorial.
    return (bboard & -bboard).bit_length() - 1


def set_bit(bboard, square: str):
    """
    Given a bitboard and a board square,
    set the corresponding bit in the bitboard"""
    if isinstance(square, int):
        return bboard | 1 << square
    return bboard | 1 << (config.BoardSquares[square].value)


def pop_bit(bboard, square: str):
    """
    Given a bitboard and a board square,
    pop the corresponding bit in the bitboard"""
    if isinstance(square, int):
        return bboard & ~(1 << square)
    return bboard & ~(1 << (config.BoardSquares[square].value))


def get_bit(bboard, index: int):
    """
    Given a bitboard, return the bit at position 'index'
    Returns 0 if the bit isn't set, else it returns the
    int rep of the bitboard
    """
    return bboard & (1 << index)


################################################
##                                            ##
##           Pseudorandom Numbers             ##
##                                            ##
################################################


def generate_pseudorandom_number_32bit():
    """
    Uses the XORShift32 algorithm
    """
    num = config.PSEUDORANDOM_NUMBER_STATE

    # The "& 0xffffffff" part is to ensure
    # we get 32-bit ints
    num ^= num << 13 & 0xFFFFFFFF
    num ^= num >> 17
    num ^= num << 5 & 0xFFFFFFFF
    """
    # Another approach, but it's almost 5X slower:
    import numpy as np

    num = np.uint32(PSEUDORANDOM_NUMBER_STATE)
    num ^= num << np.uint32(13)
    num ^= num >> np.uint32(17)
    num ^= num << np.uint32(5)
    """

    config.PSEUDORANDOM_NUMBER_STATE = num

    return num


def generate_pseudorandom_number_64bit():
    n1 = generate_pseudorandom_number_32bit() & 0xFFFF
    n2 = generate_pseudorandom_number_32bit() & 0xFFFF
    n3 = generate_pseudorandom_number_32bit() & 0xFFFF
    n4 = generate_pseudorandom_number_32bit() & 0xFFFF

    return n1 | (n2 << 16) | (n3 << 32) | (n4 << 48)


################################################
##                                            ##
##                  Magics                    ##
##                                            ##
################################################


def generate_candidate_magic_number():
    return (
        generate_pseudorandom_number_64bit()
        & generate_pseudorandom_number_64bit()
        & generate_pseudorandom_number_64bit()
    )


def find_magic_number(square: int, num_of_set_bits: int, bishop: int):
    """
    :Input:
        - square: an int representing the board square
        - num_of_set_bits
        - bishop: 0 if it's a rook and 1 if a bishop
    :Returns:
        - magic number if found
        - 0 otherwise

    Given a sliding piece on a square, it returns a magic
    number associated to that square if it can find one.
    Else, it returns 0.

    The key idea is to find a random number that assigns
    to each possible occupancy combination related to the
    attack path of the sliding piece, a unique attack.
    """
    # init occupancies:
    # we use an array of size 4096 as that's the
    # maximum size we can need (say, rook on a1)
    occupancies = [0] * 4096

    # init attacks
    attacks = [0] * 4096

    # init attack mask for current piece
    attack_mask = (
        generate_bishop_attacks(square) if bishop else generate_rook_attacks(square)
    )

    # init occupancy indices
    occupancy_indices = 1 << num_of_set_bits

    for idx in range(occupancy_indices):
        occupancies[idx] = set_occupancy(idx, num_of_set_bits, attack_mask)
        attacks[idx] = (
            bishop_attacks_on_the_fly(square, occupancies[idx])
            if bishop
            else rook_attacks_on_the_fly(square, occupancies[idx])
        )

    for _ in range(100_000_000):
        magic_cand = generate_candidate_magic_number()
        if count_bits((attack_mask * magic_cand) & 0xFF00000000000000) < 6:
            continue

        # Do we need to set used_attacks here instead? Yes.
        used_attacks = [0] * 4096

        # init fail flag
        fail = 0
        for index in range(occupancy_indices):
            # My understanding of what makes a magic candidate ideal
            # is that it should, among other things, map each occupancy
            # combination to a unique attack.

            # '& 0xffffffffffffffff' is needed to ensure 64 bits
            # and avoid having an IndexError later on when we do
            # used_attacks[magic_index]
            magic_index = ((occupancies[index] * magic_cand) & 0xFFFFFFFFFFFFFFFF) >> (
                64 - num_of_set_bits
            )
            if used_attacks[magic_index] == 0:
                used_attacks[magic_index] = attacks[index]

            elif used_attacks[magic_index] != attacks[index]:
                # Since we've seen this magic index before, then
                # it means we have a case of two occupancy combinations
                # being mapped to different attacks. Hence, we can say
                # that this candidate magic number doesn't work and can
                # be discarded.
                fail = 1
                break

        if not fail:
            # our candidate magic number works
            return magic_cand

    # If we're here, then no good magic number was found
    print("!!!!!!!!!!!!!! NO MAGIC NUMBER FOUND !!!!!!!!!!!!!!")
    return 0


################################################
##                                            ##
##                  Attacks                   ##
##                                            ##
################################################


################################################
##                                            ##
##               Leaper Attacks               ##
##                                            ##
################################################


def generate_pawn_attacks(side: str, square: str):
    attacks = 0
    bboard = 0
    bboard = set_bit(bboard, square)
    if side == "white":
        if (bboard >> 7) & config.NOT_FILE_A:
            attacks |= bboard >> 7
        if (bboard >> 9) & config.NOT_FILE_H:
            attacks |= bboard >> 9
    elif side == "black":
        if (bboard << 7) & config.NOT_FILE_H:
            attacks |= bboard << 7
        if (bboard << 9) & config.NOT_FILE_A:
            attacks |= bboard << 9
    return attacks


def generate_king_attacks(square: str):
    attacks = 0
    bboard = 0
    bboard = set_bit(bboard, square)
    if (bboard >> 1) & config.NOT_FILE_H:
        attacks |= bboard >> 1
    if (bboard >> 9) & config.NOT_FILE_H:
        attacks |= bboard >> 9
    if (bboard >> 7) & config.NOT_FILE_A:
        attacks |= bboard >> 7
    if (bboard << 1) & config.NOT_FILE_A:
        attacks |= bboard << 1
    if (bboard << 9) & config.NOT_FILE_A:
        attacks |= bboard << 9
    if (bboard << 7) & config.NOT_FILE_H:
        attacks |= bboard << 7
    attacks |= bboard >> 8
    attacks |= bboard << 8

    return attacks


def generate_knight_attacks(square: str):
    attacks = 0
    bboard = 0
    bboard = set_bit(bboard, square)
    if (bboard >> 17) & config.NOT_FILE_H:
        attacks |= bboard >> 17
    if (bboard >> 10) & config.NOT_FILE_HG:
        attacks |= bboard >> 10
    if (bboard >> 15) & config.NOT_FILE_A:
        attacks |= bboard >> 15
    if (bboard >> 6) & config.NOT_FILE_AB:
        attacks |= bboard >> 6
    if (bboard << 17) & config.NOT_FILE_A:
        attacks |= bboard << 17
    if (bboard << 10) & config.NOT_FILE_AB:
        attacks |= bboard << 10
    if (bboard << 15) & config.NOT_FILE_H:
        attacks |= bboard << 15
    if (bboard << 6) & config.NOT_FILE_HG:
        attacks |= bboard << 6

    return attacks


################################################
##                                            ##
##              Slider Attacks                ##
##                                            ##
################################################


def generate_rook_attacks(square: str):
    """
    Returns a bitboard in which all the squares--EXCEPT border squares--a
    rook on square "square" can go to have their corresponding bit index set.
    """
    relevant_rook_occ_squares = 0

    if isinstance(square, int):
        target_rank = square // 8
        target_file = square % 8
    else:
        target_rank = config.BoardSquares[square].value // 8
        target_file = config.BoardSquares[square].value % 8

    for r in range(target_rank + 1, 7):
        relevant_rook_occ_squares |= 1 << (r * 8 + target_file)

    for r in range(target_rank - 1, 0, -1):
        relevant_rook_occ_squares |= 1 << (r * 8 + target_file)

    for f in range(target_file - 1, 0, -1):
        relevant_rook_occ_squares |= 1 << (target_rank * 8 + f)

    for f in range(target_file + 1, 7):
        relevant_rook_occ_squares |= 1 << (target_rank * 8 + f)

    return relevant_rook_occ_squares


def rook_attacks_on_the_fly(square: str, block):
    """
    Returns a bitboard in which all the squares a rook on square "square"
    can go to have their corresponding bit index set, taking into account blocked squares
    defined by the bitboard "block".
    """
    relevant_rook_occ_squares = 0

    if isinstance(square, int):
        target_rank = square // 8
        target_file = square % 8
    else:
        target_rank = config.BoardSquares[square].value // 8
        target_file = config.BoardSquares[square].value % 8

    for r in range(target_rank + 1, 8):
        relevant_rook_occ_squares |= 1 << (r * 8 + target_file)
        if 1 << (r * 8 + target_file) & block:
            break

    for r in range(target_rank - 1, -1, -1):
        relevant_rook_occ_squares |= 1 << (r * 8 + target_file)
        if 1 << (r * 8 + target_file) & block:
            break

    for f in range(target_file - 1, -1, -1):
        relevant_rook_occ_squares |= 1 << (target_rank * 8 + f)
        if 1 << (target_rank * 8 + f) & block:
            break

    for f in range(target_file + 1, 8):
        relevant_rook_occ_squares |= 1 << (target_rank * 8 + f)
        if 1 << (target_rank * 8 + f) & block:
            break

    return relevant_rook_occ_squares


def get_rook_attacks(square: int, occupancy):
    if not isinstance(square, int):
        square = config.BoardSquares[square].value
    occupancy &= config.ROOK_MASKS[square]
    occupancy *= config.ROOK_MAGIC_NUMBERS[square]
    occupancy &= 0xFFFFFFFFFFFFFFFF
    occupancy >>= 64 - config.ROOK_RELEVANCY_OCC_COUNT[square]

    return config.ROOK_ATTACKS[square][occupancy]


def generate_bishop_attacks(square: str):
    """
    Returns a bitboard in which all the squares--EXCEPT border squares--a
    bishop on square "square" can go to have their corresponding bit index set.
    """
    relevant_bishop_occ_squares = 0

    if isinstance(square, int):
        target_rank = square // 8
        target_file = square % 8
    else:
        target_rank = config.BoardSquares[square].value // 8
        target_file = config.BoardSquares[square].value % 8

    for r, f in zip(range(target_rank + 1, 7), range(target_file + 1, 7)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)

    for r, f in zip(range(target_rank - 1, 0, -1), range(target_file + 1, 7)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)

    for r, f in zip(range(target_rank + 1, 7), range(target_file - 1, 0, -1)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)

    for r, f in zip(range(target_rank - 1, 0, -1), range(target_file - 1, 0, -1)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)

    return relevant_bishop_occ_squares


def bishop_attacks_on_the_fly(square: str, block):
    """
    Returns a bitboard in which all the squares a bishop on square "square"
    can go to have their corresponding bit index set, taking into account blocked squares
    defined by the bitboard "block".
    """
    relevant_bishop_occ_squares = 0

    if isinstance(square, int):
        target_rank = square // 8
        target_file = square % 8
    else:
        target_rank = config.BoardSquares[square].value // 8
        target_file = config.BoardSquares[square].value % 8

    for r, f in zip(range(target_rank + 1, 8), range(target_file + 1, 8)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)
        if 1 << (r * 8 + f) & block:
            break

    for r, f in zip(range(target_rank - 1, -1, -1), range(target_file + 1, 8)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)
        if 1 << (r * 8 + f) & block:
            break

    for r, f in zip(range(target_rank + 1, 8), range(target_file - 1, -1, -1)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)
        if 1 << (r * 8 + f) & block:
            break

    for r, f in zip(range(target_rank - 1, -1, -1), range(target_file - 1, -1, -1)):
        relevant_bishop_occ_squares |= 1 << (r * 8 + f)
        if 1 << (r * 8 + f) & block:
            break

    return relevant_bishop_occ_squares


def get_bishop_attacks(square: int, occupancy):
    if not isinstance(square, int):
        square = config.BoardSquares[square].value
    occupancy &= config.BISHOP_MASKS[square]
    occupancy *= config.BISHOP_MAGIC_NUMBERS[square]
    occupancy &= 0xFFFFFFFFFFFFFFFF
    occupancy >>= 64 - config.BISHOP_RELEVANCY_OCC_COUNT[square]

    return config.BISHOP_ATTACKS[square][occupancy]


def get_queen_attacks(square: int, occupancy):
    return get_bishop_attacks(square, occupancy) | get_rook_attacks(square, occupancy)


def queen_attacks_on_the_fly(square: int, block):
    return bishop_attacks_on_the_fly(square, block) | rook_attacks_on_the_fly(
        square, block
    )


def is_square_attacked(square: int, side: str):
    """
    Checks if given square is attacked by any of
    the side 'side' pieces. So to check if say, 'f4'
    is attacked by any black piece, pass 'f4' and
    'black'

    """
    side_to_int = config.Colours[side].value
    pawn = "P" if side == "white" else "p"
    knight = "N" if side == "white" else "n"
    bishop = "B" if side == "white" else "b"
    rook = "R" if side == "white" else "r"
    queen = "Q" if side == "white" else "q"
    king = "K" if side == "white" else "k"
    return (
        (
            config.PAWN_ATTACKS[side_to_int ^ 1][square]
            & config.PIECE_BITBOARDS[config.Pieces[pawn].value]
        )
        | (
            config.KNIGHT_ATTACKS[square]
            & config.PIECE_BITBOARDS[config.Pieces[knight].value]
        )
        | (
            get_bishop_attacks(square, config.OCCUPANCIES[2])
            & config.PIECE_BITBOARDS[config.Pieces[bishop].value]
        )
        |
        (
            get_rook_attacks(square, config.OCCUPANCIES[2])
            & config.PIECE_BITBOARDS[config.Pieces[rook].value]
        )
        |
        (
            get_queen_attacks(square, config.OCCUPANCIES[2])
            & config.PIECE_BITBOARDS[config.Pieces[queen].value]
        )
        |
        (
            config.KING_ATTACKS[square]
            & config.PIECE_BITBOARDS[config.Pieces[king].value]
        )
    )


def set_occupancy(index: int, num_of_set_bits_in_mask: int, attack_mask: int):
    """
    With any given index, you get a bitboard showing
    one possible occupancy combination you might expect
    for a sliding piece set on a particular square (this
    square is indicated by the attack mask passed as a
    parameter to the function). Observe that the same
    index paired with the same attack mask will always
    result in the same occupancy combination.

    There are (2**num_of_set_bits_in_mask) such possible
    occupancy combinations."""

    occupancy = 0

    for i in range(num_of_set_bits_in_mask):
        square = get_lsb_index(attack_mask)

        # Crucial, if we don't want to keep getting the same LSB index
        attack_mask = pop_bit(attack_mask, square)

        # We only update occupancy when the i-th bit
        # in the index is set. This way, two different
        # indices (within the range(2**num_of_set_bits_in_mask) )
        # will give different occupancy combinations.
        # (After 2**num_of_set_bits_in_mask, the combinations
        # begin to repeat.)
        if index & (1 << i):
            occupancy |= 1 << square

    return occupancy


################################################
##                                            ##
##               Move Encoding                ##
##                                            ##
################################################


def encode_move(
    source: int,
    target: int,
    moving_piece: int,
    promoted_piece: int,
    capture: int,
    double_pawn_push: int,
    enpassant: int,
    castling: int,
):
    source = source if isinstance(source, int) else config.BoardSquares[source].value
    target = target if isinstance(target, int) else config.BoardSquares[target].value
    moving_piece = (
        moving_piece
        if isinstance(moving_piece, int)
        else config.Pieces[moving_piece].value
    )
    promoted_piece = (
        promoted_piece
        if isinstance(promoted_piece, int)
        else config.Pieces[promoted_piece].value
    )

    return (
        source
        | (target << 6)
        | (moving_piece << 12)
        | (promoted_piece << 16)
        | (capture << 20)
        | (double_pawn_push << 21)
        | (enpassant << 22)
        | (castling << 23)
    )


def add_move_to_move_list(move: int, move_list: list):
    move_list.append(move)
    config.MOVE_LIST[config.MOVE_COUNT] = move
    config.MOVE_COUNT += 1


def make_move(move: int, only_captures=False):
    if not only_captures:
        # We first need to preserve current board state
        copy_board_state()
        own_colour = config.Colours[config.SIDE_TO_MOVE].value

        # Now we parse the move
        source_square = get_move_source(move)
        target_square = get_move_target(move)
        moving_piece = get_move_piece(move)
        promoted_piece = get_move_promoted_piece(move)
        capture = get_move_capture(move)
        double_pawn_push = get_move_double_pawn_push(move)
        en_passant_capture = get_move_en_passant(move)
        castling = get_move_castling(move)

        # FOR TESTING PURPOSES
        previous_hash = config.HASH_KEY

        ## hash piece: XOR (piece, source) and (piece, target) into hash key
        config.HASH_KEY ^= config.PIECE_KEYS[moving_piece][source_square]
        config.HASH_KEY ^= config.PIECE_KEYS[moving_piece][target_square]
        config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        offset_cap, offset_prom, offset_doublepawn, own_colour__, king = (
            (6, 0, 8, 0, "K") if config.SIDE_TO_MOVE == "white" else (0, 6, -8, 1, "k")
        )

        # Update appropriate piece bitboard
        config.PIECE_BITBOARDS[moving_piece] = pop_bit(
            set_bit(config.PIECE_BITBOARDS[moving_piece], target_square), source_square
        )

        # Update occupancy bitboard for the current side
        config.OCCUPANCIES[own_colour] = pop_bit(
            set_bit(config.OCCUPANCIES[own_colour], target_square), source_square
        )

        if promoted_piece:
            # Remove the pawn that we set above in its bitboard
            config.PIECE_BITBOARDS[moving_piece] = pop_bit(
                config.PIECE_BITBOARDS[moving_piece], target_square
            )
            # update hash key: remove pawn
            config.HASH_KEY ^= config.PIECE_KEYS[moving_piece][target_square]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

            # Set the piece we're promoting to
            config.PIECE_BITBOARDS[promoted_piece - offset_cap] = set_bit(
                config.PIECE_BITBOARDS[promoted_piece - offset_cap], target_square
            )
            # Update hash key: add promoted piece
            config.HASH_KEY ^= config.PIECE_KEYS[promoted_piece - offset_cap][
                target_square
            ]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        if capture:
            # If there was a capture, then we need to update
            # the bitboard of the captured piece

            # Testing purposes only!!!
            # found = 0

            for idx in range(6):
                captured_piece = idx + offset_cap
                if get_bit(config.PIECE_BITBOARDS[captured_piece], target_square):
                    # This was the piece we captured. We pop
                    # its bit from its piece bitboard
                    config.PIECE_BITBOARDS[captured_piece] = pop_bit(
                        config.PIECE_BITBOARDS[captured_piece], target_square
                    )

                    # update hash key: XOR (captured_piece, target) into hash key
                    config.HASH_KEY ^= config.PIECE_KEYS[captured_piece][target_square]
                    config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

                    # Update occupancies for the side whose piece
                    # was captured
                    config.OCCUPANCIES[own_colour ^ 1] = pop_bit(
                        config.OCCUPANCIES[own_colour ^ 1], target_square
                    )

                    break

        if castling:
            # check which side we're castling to
            rook = "r" if config.SIDE_TO_MOVE == "black" else "R"
            current_rook_square_offset, new_rook_square_offset = (
                (1, 1) if target_square > source_square else (-2, -1)
            )

            # Update the appropriate side's rook bitboard:
            # Pop it from the edge square and set it in the
            # castled square
            config.PIECE_BITBOARDS[config.Pieces[rook].value] = pop_bit(
                set_bit(
                    config.PIECE_BITBOARDS[config.Pieces[rook].value],
                    target_square - new_rook_square_offset,
                ),
                target_square + current_rook_square_offset,
            )

            # update hash key: XOR (rook, source_square) and (rook, target_square) into hash key
            config.HASH_KEY ^= config.PIECE_KEYS[config.Pieces[rook].value][
                target_square + current_rook_square_offset
            ]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF
            config.HASH_KEY ^= config.PIECE_KEYS[config.Pieces[rook].value][
                target_square - new_rook_square_offset
            ]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

            # Update occupancies taking into account the rook movement
            config.OCCUPANCIES[own_colour] = pop_bit(
                set_bit(
                    config.OCCUPANCIES[own_colour],
                    target_square - new_rook_square_offset,
                ),
                target_square + current_rook_square_offset,
            )

        if en_passant_capture:
            # We make sure to remove the pawn that has now
            # been captured through en passant
            config.PIECE_BITBOARDS[offset_cap] = pop_bit(
                config.PIECE_BITBOARDS[offset_cap], target_square + offset_doublepawn
            )

            # update hash key with en passant capture:
            config.HASH_KEY ^= config.PIECE_KEYS[offset_cap][
                target_square + offset_doublepawn
            ]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

            # Update occupancies for the other side taking
            # into account the en passant capture
            config.OCCUPANCIES[own_colour ^ 1] = pop_bit(
                config.OCCUPANCIES[own_colour ^ 1], target_square + offset_doublepawn
            )

        # reset castling right in hash_key
        config.HASH_KEY ^= config.CASTLING_KEYS[config.CASTLING_RIGHT]
        config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        # We update castling right after every move.
        # Castling right only changes if at least one of
        # source and target squares is a rooks' or kings'
        # starting square.
        config.CASTLING_RIGHT &= (
            config.CASTLING_RIGHT_LOOKUP_TABLE[source_square]
            & config.CASTLING_RIGHT_LOOKUP_TABLE[target_square]
        )

        # now update hash_key with new castling right
        config.HASH_KEY ^= config.CASTLING_KEYS[config.CASTLING_RIGHT]
        config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        # hash enpassant square (if available)
        if config.ENPASSANT_SQUARE != "no_square":
            config.HASH_KEY ^= config.ENPASSANT_KEYS[
                config.BoardSquares[config.ENPASSANT_SQUARE].value
            ]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        # As long as we're not making a double pawn push,
        # we always reset the en passant square to empty.
        # This is because, per the rules, en passant capture
        # is only available for the very next move after
        # a double pawn push.
        config.ENPASSANT_SQUARE = "no_square"

        if double_pawn_push:
            # We set the en passant square
            config.ENPASSANT_SQUARE = config.SQUARES[target_square + offset_doublepawn]

            # update hash key with en passant square
            config.HASH_KEY ^= config.ENPASSANT_KEYS[target_square + offset_doublepawn]
            config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        # We update the occupancy for both sides
        config.OCCUPANCIES[2] = config.OCCUPANCIES[0] | config.OCCUPANCIES[1]

        # Update side to move
        config.SIDE_TO_MOVE = config.SIDES[own_colour ^ 1]

        config.HASH_KEY ^= config.SIDE_KEY
        config.HASH_KEY &= 0xFFFFFFFFFFFFFFFF

        # Check if the move just registered leaves the king in check
        king_bitboard = config.PIECE_BITBOARDS[config.Pieces[king].value]
        king_square = get_lsb_index(king_bitboard)

        if is_square_attacked(king_square, config.SIDE_TO_MOVE):
            restore_board_state()

            # RESTORE PREVIOUS HASH??
            config.HASH_KEY = previous_hash
            return False
        else:
            # Move's fine

            return True

    else:
        if get_move_capture(move):
            return make_move(move, False)
        else:
            return False


################################################
##                                            ##
##               Move Decoding                ##
##                                            ##
################################################


def get_move_source(move: int):
    return move & config.SOURCE_SQUARE_MASK


def get_move_target(move: int):
    return (move & config.TARGET_SQUARE_MASK) >> 6


def get_move_piece(move: int):
    return (move & config.MOVING_PIECE_MASK) >> 12


def get_move_promoted_piece(move: int):
    return (move & config.PROMOTED_PIECE_MASK) >> 16


def get_move_capture(move: int):
    return move & config.CAPTURE_MASK


def get_move_double_pawn_push(move: int):
    return move & config.DOUBLE_PAWN_PUSH_MASK


def get_move_en_passant(move: int):
    return move & config.EN_PASSANT_MASK


def get_move_castling(move: int):
    return move & config.CASTLING_MASK


################################################
##                                            ##
##              Move Generation               ##
##                                            ##
################################################


def get_pawn_moves(
    square: int, offset: int, own_colour_index: int, piece: str, move_list
):
    """
    Gets pawn moves on a given square and for a given side.

    The idea is the following:
        - check if pawn can move one square forward.
            if not, no move is possible and the LHS
            of the multiplier resolves to zero.
        - check if double pawn push is possible
        - return list of human-readable designations
            of legal moves
    :Inputs:
        - offset +8 if black else -8
    """
    # prom_squares = [1, 2, 3, 4] if own_colour_index == "0" else [7, 8, 9, 10]
    move = (1 - (1 & (config.OCCUPANCIES[2] >> (square + offset)))) * (
        config.PAWN_MOVES_MASKS[own_colour_index][square] & ~config.OCCUPANCIES[2]
    )
    valid_moves = []
    while move:
        target_square = get_lsb_index(move)
        valid_moves.append(config.SQUARES[target_square])
        move = pop_bit(move, config.SQUARES[target_square])
        if target_square in range(8) or target_square in range(56, 64):
            # We're promoting the pawn.
            # For now, we add move with all promotion candidates.
            for num in [10, 9, 8, 7]:
                move_enc = encode_move(
                    square,
                    target_square,
                    config.Pieces[piece].value,
                    num,
                    0,
                    0,
                    0,
                    0,
                )
                add_move_to_move_list(move_enc, move_list)
        else:
            if abs(target_square - square) == 16:
                # We're making a double pawn push
                # Should update en passant square here (not doing it yet)
                # config.ENPASSANT_SQUARE = config.SQUARES[target_square - offset]
                move_enc = encode_move(
                    square,
                    target_square,
                    config.Pieces[piece].value,
                    0,
                    0,
                    1,
                    0,
                    0,
                )
                add_move_to_move_list(move_enc, move_list)
            else:
                # Single pawn push
                move_enc = encode_move(
                    square,
                    target_square,
                    config.Pieces[piece].value,
                    0,
                    0,
                    0,
                    0,
                    0,
                )
                add_move_to_move_list(move_enc, move_list)
    return valid_moves


def generate_pawn_moves(
    bitboard: int, offset: int, own_colour_index: int, piece: str, move_list
):
    """
    - offset 8 if black else -8
    """
    while bitboard:
        source_square = get_lsb_index(bitboard)
        bitboard = pop_bit(bitboard, source_square)
        # Crucial: We're not checking if we're moving from a right square.
        # It's being handled by the get_pawn_moves function it seems
        captures = (
            config.PAWN_ATTACKS[own_colour_index][source_square]
            & config.OCCUPANCIES[own_colour_index ^ 1]
        )
        valid_captures = []

        en_passant_capture = config.ENPASSANT_SQUARE != "no_square" and (
            config.PAWN_ATTACKS[own_colour_index][source_square]
            & (1 << config.BoardSquares[config.ENPASSANT_SQUARE].value)
        )
        if en_passant_capture:
            # Encode en passant capture
            move = encode_move(
                source_square,
                config.BoardSquares[config.ENPASSANT_SQUARE].value,
                config.Pieces[piece].value,
                0,
                1,
                0,
                1,
                0,
            )
            add_move_to_move_list(move, move_list)

        while captures:
            target_square = get_lsb_index(captures)
            captures = pop_bit(captures, target_square)
            valid_captures.append(config.SQUARES[target_square])
            if target_square in range(8) or target_square in range(56, 64):
                # We're promoting the pawn.
                # For now, we add move with all promotion candidates.
                for num in [10, 9, 8, 7]:
                    move = encode_move(
                        source_square,
                        target_square,
                        config.Pieces[piece].value,
                        num,
                        1,
                        0,
                        0,
                        0,
                    )
                    add_move_to_move_list(move, move_list)
            else:
                # Regular capture
                move = encode_move(
                    source_square,
                    target_square,
                    config.Pieces[piece].value,
                    0,
                    1,
                    0,
                    0,
                    0,
                )
                add_move_to_move_list(move, move_list)

        # Note that this assumes everything has been set up properly (the
        # correct side to move, en passant valid for only one move, etc)
        get_pawn_moves(source_square, offset, own_colour_index, piece, move_list)


def is_king_under_check(square: str, opponent):
    """
    Helper function to determine if king on square
    'square' is under check.
    """
    return is_square_attacked(config.BoardSquares[square].value, opponent)


def generate_castling_moves(king: str, queen: str, rank: str, opponent: str):
    """
    :Inputs:
        - king = 'K' if white else 'k'
        - queen = 'Q' if white else 'q'
        - rank is either 1 or 8
        - opponent is 'white' if side to move is black else 'black'

    :Outputs:
        - boolean indicating ability to castle kingside
        - boolean indicating ability to castle queenside

    IMPORTANT: This function assumes that castling rights have been set up properly!

    Castling rules: 'Castling is permitted only if neither the king nor the rook
    has previously moved (we're not checking these in this function); the squares
    between the king and the rook are vacant; and the king does not leave (e),
    cross over (d or f), or finish (c or g) on a square attacked by an enemy piece.'

    Source: 'https://en.wikipedia.org/wiki/Castling'
    (Words in parantheses mine)
    """
    not_king_under_check = not is_king_under_check(f"e{rank}", opponent)

    can_castle_kingside = (
        (config.CASTLING_RIGHT & config.Castling[king].value)
        and not is_square_attacked(config.BoardSquares[f"f{rank}"].value, opponent)
        and not (3 << config.BoardSquares[f"g{rank}"].value - 1) & config.OCCUPANCIES[2]
    )

    can_castle_queenside = (
        (config.CASTLING_RIGHT & config.Castling[queen].value)
        and not is_square_attacked(config.BoardSquares[f"d{rank}"].value, opponent)
        and not (7 << config.BoardSquares[f"d{rank}"].value - 2) & config.OCCUPANCIES[2]
    )

    return (
        not_king_under_check and can_castle_kingside,
        not_king_under_check and can_castle_queenside,
    )


def generate_non_pawn_moves(
    source_square: int, own_colour_index: int, attacks: int, piece: str, move_list
):
    """
    Doesn't generate castling moves. That's handled elsewhere.
    """
    non_capture_moves = attacks & ~config.OCCUPANCIES[2] & 0xFFFFFFFFFFFFFFFF
    captures = attacks & config.OCCUPANCIES[own_colour_index ^ 1] & 0xFFFFFFFFFFFFFFFF

    while captures:
        target_square = get_lsb_index(captures)
        captures = pop_bit(captures, target_square)  # & int(hex((2 ** 64) - 1), 16)
        move = encode_move(
            source_square,
            target_square,
            config.Pieces[piece].value,
            0,
            1,
            0,
            0,
            0,
        )
        add_move_to_move_list(move, move_list)

    while non_capture_moves:
        target_square = get_lsb_index(non_capture_moves)
        non_capture_moves = pop_bit(
            non_capture_moves, target_square
        )  # & int(hex((2 ** 64) - 1), 16)
        move = encode_move(
            source_square,
            target_square,
            config.Pieces[piece].value,
            0,
            0,
            0,
            0,
            0,
        )
        add_move_to_move_list(move, move_list)


def generate_moves():
    """
    Function to generate moves for the current side to move.
    It generates all possible moves considering all the
    side's available pieces.
    """
    # Initialise move count to zero
    config.MOVE_COUNT = 0

    move_list = []

    for bitboard, piece in zip(config.PIECE_BITBOARDS, config.ASCII_PIECES):
        own_colour_index = config.Colours[config.SIDE_TO_MOVE].value

        if config.SIDE_TO_MOVE == "white":
            # Handle white pawn moves and king castling
            if piece == "P":
                generate_pawn_moves(bitboard, -8, own_colour_index, piece, move_list)
            # White king castling
            elif piece == "K":
                # # Ensure that we have the appropriate castling rights
                # # and the squares between the king rook are unoccupied.
                can_castle_kingside, can_castle_queenside = generate_castling_moves(
                    "K", "Q", 1, "black"
                )
                if can_castle_kingside:
                    move = encode_move(
                        config.BoardSquares["e1"].value,
                        config.BoardSquares["g1"].value,
                        config.Pieces["K"].value,
                        0,
                        0,
                        0,
                        0,
                        1,
                    )
                    add_move_to_move_list(move, move_list)
                if can_castle_queenside:
                    move = encode_move(
                        config.BoardSquares["e1"].value,
                        config.BoardSquares["c1"].value,
                        config.Pieces["K"].value,
                        0,
                        0,
                        0,
                        0,
                        1,
                    )
                    add_move_to_move_list(move, move_list)

        elif config.SIDE_TO_MOVE == "black":
            # Handle black pawn moves and king castling
            if piece == "p":
                generate_pawn_moves(bitboard, 8, own_colour_index, piece, move_list)
            # Black king castling
            elif piece == "k":
                # # Ensure that we have the appropriate castling rights
                # # and the squares between the king rook are unoccupied.
                can_castle_kingside, can_castle_queenside = generate_castling_moves(
                    "k", "q", 8, "white"
                )
                if can_castle_kingside:
                    move = encode_move(
                        config.BoardSquares["e8"].value,
                        config.BoardSquares["g8"].value,
                        config.Pieces["k"].value,
                        0,
                        0,
                        0,
                        0,
                        1,
                    )
                    add_move_to_move_list(move, move_list)
                if can_castle_queenside:
                    move = encode_move(
                        config.BoardSquares["e8"].value,
                        config.BoardSquares["c8"].value,
                        config.Pieces["k"].value,
                        0,
                        0,
                        0,
                        0,
                        1,
                    )
                    add_move_to_move_list(move, move_list)

        # Generate knight moves
        if (piece == "n" and config.SIDE_TO_MOVE == "black") or (
            piece == "N" and config.SIDE_TO_MOVE == "white"
        ):
            while bitboard:
                source_square = get_lsb_index(bitboard)
                attacks = config.KNIGHT_ATTACKS[source_square]
                generate_non_pawn_moves(
                    source_square, own_colour_index, attacks, piece, move_list
                )

                bitboard = pop_bit(bitboard, source_square)

        # Generate rook moves
        if (piece == "r" and config.SIDE_TO_MOVE == "black") or (
            piece == "R" and config.SIDE_TO_MOVE == "white"
        ):
            while bitboard:
                source_square = get_lsb_index(bitboard)
                attacks = get_rook_attacks(source_square, config.OCCUPANCIES[2])
                generate_non_pawn_moves(
                    source_square, own_colour_index, attacks, piece, move_list
                )

                bitboard = pop_bit(bitboard, source_square)

        # Generate bishop moves
        if (piece == "b" and config.SIDE_TO_MOVE == "black") or (
            piece == "B" and config.SIDE_TO_MOVE == "white"
        ):
            while bitboard:
                source_square = get_lsb_index(bitboard)
                attacks = get_bishop_attacks(source_square, config.OCCUPANCIES[2])
                generate_non_pawn_moves(
                    source_square, own_colour_index, attacks, piece, move_list
                )

                bitboard = pop_bit(bitboard, source_square)

        # Generate queen moves
        if (piece == "q" and config.SIDE_TO_MOVE == "black") or (
            piece == "Q" and config.SIDE_TO_MOVE == "white"
        ):
            while bitboard:
                source_square = get_lsb_index(bitboard)
                attacks = get_queen_attacks(source_square, config.OCCUPANCIES[2])
                generate_non_pawn_moves(
                    source_square, own_colour_index, attacks, piece, move_list
                )

                bitboard = pop_bit(bitboard, source_square)

        # Generate king moves different from castling
        if (piece == "k" and config.SIDE_TO_MOVE == "black") or (
            piece == "K" and config.SIDE_TO_MOVE == "white"
        ):
            while bitboard:
                source_square = get_lsb_index(bitboard)
                attacks = config.KING_ATTACKS[source_square]
                generate_non_pawn_moves(
                    source_square, own_colour_index, attacks, piece, move_list
                )

                bitboard = pop_bit(bitboard, source_square)
    return move_list


def move_to_str(move):
    promoted_piece = get_move_promoted_piece(move)
    promoted_piece_str = " "
    if promoted_piece:
        promoted_piece_str = config.ASCII_PIECES[promoted_piece].lower()
    source_square = config.SQUARES[get_move_source(move)]
    target_square = config.SQUARES[get_move_target(move)]
    return source_square + target_square + promoted_piece_str


def write_to_transposition_table(
    score, depth, hash_flag, ply, hash_key=config.HASH_KEY
):
    # Position in table to write to
    index = hash_key % config.HASH_TABLE_SIZE

    # Store score independent of path from root to current node
    if score < -config.MATE_SCORE:
        score -= config.PLY
    elif score > config.MATE_SCORE:
        score += config.PLY

    entry = {
        "hash_key": hash_key,
        "depth": depth,
        "node_score": score,
        "hash_flag": hash_flag,
    }
    # Now write to table
    config.TRANSPOSITION_TABLE[index] = entry


def read_hash_entry(alpha, beta, depth, ply, hash_key=config.HASH_KEY):
    # Get entry corresponding to current hash key if available
    index = hash_key % config.HASH_TABLE_SIZE
    # Confirm that entry is for the current position
    if config.TRANSPOSITION_TABLE[index]:
        entry = config.TRANSPOSITION_TABLE[index]
        if hash_key != entry["hash_key"] or entry["depth"] < depth:
            return config.HASH_ENTRY_NOT_FOUND

        stored_flag = entry["hash_flag"]
        stored_score = entry["node_score"]

        # Retrieve score independent of path from root to current node
        if stored_score < -config.MATE_SCORE:
            stored_score += config.PLY
        elif stored_score > config.MATE_SCORE:
            stored_score -= config.PLY

        if stored_flag == config.HASH_ALPHA_FLAG and stored_score <= alpha:
            return alpha
        elif stored_flag == config.HASH_BETA_FLAG and stored_score >= beta:
            return beta
        elif stored_flag == config.HASH_EXACT_FLAG:
            return stored_score
    return config.HASH_ENTRY_NOT_FOUND


def clear_transposition_table():
    if isinstance(config.TRANSPOSITION_TABLE, dict):
        for item in config.TRANSPOSITION_TABLE:
            config.TRANSPOSITION_TABLE[item]["hash_key"] = 0
            config.TRANSPOSITION_TABLE[item]["depth"] = 0
            config.TRANSPOSITION_TABLE[item]["flag"] = 0
            config.TRANSPOSITION_TABLE[item]["score"] = 0
    elif isinstance(config.TRANSPOSITION_TABLE, list):
        config.TRANSPOSITION_TABLE.clear()
        config.TRANSPOSITION_TABLE = [0] * config.HASH_TABLE_SIZE


def generate_hash_keys(show_bitboard=False):
    FINAL_HASH_KEY = 0
    for i in range(12):
        bitboard = config.PIECE_BITBOARDS[i]
        if show_bitboard:
            print(f"Showing bitboard {config.ASCII_PIECES[i]} from generate hash key.")
            print_bitboard(bitboard)
        while bitboard:
            square = get_lsb_index(bitboard)
            FINAL_HASH_KEY ^= config.PIECE_KEYS[i][square]
            FINAL_HASH_KEY &= 0xFFFFFFFFFFFFFFFF

            bitboard = pop_bit(bitboard, square)

    if config.ENPASSANT_SQUARE != "no_square":
        FINAL_HASH_KEY ^= config.ENPASSANT_KEYS[
            config.BoardSquares[config.ENPASSANT_SQUARE].value
        ]
        FINAL_HASH_KEY &= 0xFFFFFFFFFFFFFFFF
    # Hash current castling right
    FINAL_HASH_KEY ^= config.CASTLING_KEYS[config.CASTLING_RIGHT]
    if config.SIDE_TO_MOVE == "black":
        FINAL_HASH_KEY ^= config.SIDE_KEY
        FINAL_HASH_KEY &= 0xFFFFFFFFFFFFFFFF
    return FINAL_HASH_KEY  


################################################
##                                            ##
##              Init functions                ##
##                                            ##
################################################


def init_random_hash_keys():
    config.PSEUDORANDOM_NUMBER_STATE = 1804289383
    # start with piece hash keys
    for piece in range(12):
        for square in range(64):
            config.PIECE_KEYS[piece][square] = generate_pseudorandom_number_64bit()

    # enpassant keys
    for sq in range(64):
        config.ENPASSANT_KEYS[sq] = generate_pseudorandom_number_64bit()

    # castling keys
    for num in range(16):
        config.CASTLING_KEYS[num] = generate_pseudorandom_number_64bit()

    # side key
    config.SIDE_KEY = generate_pseudorandom_number_64bit()


def init_magic_numbers():
    for sq in range(64):
        print(f"{hex(find_magic_number(sq, config.ROOK_RELEVANCY_OCC_COUNT[sq], 0))},")

    print("***********************************")
    print("***********************************")
    print("***********************************")

    for sq in range(64):
        print(
            f"{hex(find_magic_number(sq, config.BISHOP_RELEVANCY_OCC_COUNT[sq], 1))},"
        )


def init_sliders_attacks(bishop):
    for square in range(64):
        # First, we initialise the attack mask for this square
        if bishop:
            config.BISHOP_MASKS[square] = generate_bishop_attacks(square)
            attack_mask = config.BISHOP_MASKS[square]
            magic_number = config.BISHOP_MAGIC_NUMBERS[square]
        else:
            config.ROOK_MASKS[square] = generate_rook_attacks(square)
            attack_mask = config.ROOK_MASKS[square]
            magic_number = config.ROOK_MAGIC_NUMBERS[square]

        # Then we get the number of set bits in the mask
        relevant_bits_count = count_bits(attack_mask)

        occupancy_indices = 1 << relevant_bits_count

        for index in range(occupancy_indices):
            occupancy = set_occupancy(index, relevant_bits_count, attack_mask)
            # '& 0xffffffffffffffff' ensures 64 bits
            if bishop:
                # init magic index
                magic_index = ((occupancy * magic_number) & 0xFFFFFFFFFFFFFFFF) >> (
                    64 - relevant_bits_count
                )

                # init bishop attacks
                config.BISHOP_ATTACKS[square][magic_index] = bishop_attacks_on_the_fly(
                    square, occupancy
                )
            else:
                # init magic index
                magic_index = ((occupancy * magic_number) & 0xFFFFFFFFFFFFFFFF) >> (
                    64 - relevant_bits_count
                )

                # init rook attacks
                config.ROOK_ATTACKS[square][magic_index] = rook_attacks_on_the_fly(
                    square, occupancy
                )


def init_leaper_attacks():
    for num in range(64):
        config.PAWN_ATTACKS[config.Colours["white"].value][num] = generate_pawn_attacks(
            "white", num
        )
        config.PAWN_ATTACKS[config.Colours["black"].value][num] = generate_pawn_attacks(
            "black", num
        )
        config.KNIGHT_ATTACKS[num] = generate_knight_attacks(num)
        config.KING_ATTACKS[num] = generate_king_attacks(num)


def init_pawn_moves_mask():
    for square in range(8, 56):
        # set double pawn push for second and seventh ranks
        if square in range(8, 16):
            config.PAWN_MOVES_MASKS[config.Colours["black"].value][square] = (
                1 << square + 16
            )
        elif square in range(48, 56):
            config.PAWN_MOVES_MASKS[config.Colours["white"].value][square] = (
                1 << square - 16
            )

        # regular pawn push
        config.PAWN_MOVES_MASKS[config.Colours["white"].value][square] |= (
            1 << square - 8
        )
        config.PAWN_MOVES_MASKS[config.Colours["black"].value][square] |= 1 << (
            square + 8
        )


def init_all():
    init_pawn_moves_mask()
    init_leaper_attacks()
    init_sliders_attacks(1)
    init_sliders_attacks(0)
    # init_magic_numbers()
    init_random_hash_keys()
    clear_transposition_table()


################################################
##                                            ##
##              Print functions               ##
##                                            ##
################################################


def print_move_list(move_list):
    if not move_list:
        print("\n    No moves available!")
        return
    print("\n    move    piece   capture   double    enpass    castling\n")
    for move in move_list:
        if not move:
            break
        print(
            f"    {move_to_str(move)}"
            f"    {config.ASCII_PIECES[get_move_piece(move)]}"
            f"       {get_move_capture(move) >> 20}"
            f"         {get_move_double_pawn_push(move) >> 21}"
            f"         {get_move_en_passant(move) >> 22}"
            f"         {get_move_castling(move) >> 23}"
        )
    print(f"\n\n    Total number of moves: {len(move_list)}")


def print_move(move, go_to_newline: bool = True):
    """
    Apparently, the UCI protocol, which most chess engines follow,
    dictates that moves should be represented in the following manner:

    source_square + target_square + promoted_piece if any;

    'source_square' and 'target_square' refer to the algebraic representation
    of the squares (e.g., 'e4', 'h2', etc.);

    'promoted_piece' refers to the single-letter representation of the piece
    we're promoting to in that move, and must always be in lower case
    regardless of side_to_move (as opposed to traditional
    practice of encoding white pieces in upper case and black in lower).
    """
    if go_to_newline:
        print(move_to_str(move))
    else:
        print(move_to_str(move), end="")


def print_score_move(move_list: list):
    for move in move_list:
        print("    ", end="")
        print_move(move, False)
        print(f"score: {score_move(move)}")


def print_attacked_squares(side: str):
    """
    Helper function for visualising all squares
    attacked by pieces of side 'side'.
    """
    print()
    for rank in range(8):
        for file in range(8):
            square = rank * 8 + file
            if not file:
                print(f"{8-rank}   ", end="")
            val = 1 if is_square_attacked(square, side) else 0
            if file < 7:
                print(f" {val} ", end="")
            else:
                print(f" {val} ")
    print("\n     a  b  c  d  e  f  g  h\n")


def print_bitboard(bboard: int):
    """
    Helper function to print a (64-bit?) bitboard
    """
    print()
    for rank in range(8):
        for file in range(8):
            if not file:
                print(f"{8-rank}   ", end="")
            square = rank * 8 + file
            val = 1 if get_bit(bboard, square) else 0
            if file < 7:
                print(f" {val} ", end="")
            else:
                print(f" {val} ")
    print("\n     a  b  c  d  e  f  g  h\n")

    # Print the bitboard as an integer
    print(f"     Bitboard: {bboard}")


def print_board():
    print()
    for r in range(8):
        for f in range(8):
            if not f:
                print(f"{8 - r}   ", end="")
            square = r * 8 + f
            piece = "."  
            for idx, piece_bboard in enumerate(config.PIECE_BITBOARDS):
                if get_bit(piece_bboard, square):
                    piece = config.ASCII_PIECES[idx]
                    break
            if f < 7:
                print(f" {piece} ", end="")
            else:
                print(f" {piece} ")

    print("\n     a  b  c  d  e  f  g  h\n")
    print(f"     Side to move:    {config.SIDE_TO_MOVE}")
    print(
        f"     Enpassant square: {'None' if config.ENPASSANT_SQUARE == 'no_square' else config.ENPASSANT_SQUARE}"
    )

    K = "K" if config.CASTLING_RIGHT & 8 else "-"
    Q = "Q" if config.CASTLING_RIGHT & 4 else "-"
    k = "k" if config.CASTLING_RIGHT & 2 else "-"
    q = "q" if config.CASTLING_RIGHT & 1 else "-"

    print(f"     Castling rights:  {K + Q + k + q}")
    print(f"     Hash key:  {hex(config.HASH_KEY)}")
